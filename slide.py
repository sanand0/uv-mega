#!uv run
#
# Via https://chatgpt.com/share/67b83b6f-30d8-800c-9ea2-549bffc645e0
#
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "markdown2",
#     "rich",
# ]
# ///
"""
Usage:
  uv run slide.py script.md         # Resets state and renders the first slide from script.md
  uv run slide.py                   # Renders the next slide from the stored state
  uv run slide.py [--prev | -p]     # Renders the previous slide from the stored state
  uv run slide.py [--current | -c]  # Re-renders the current slide from the stored state
"""

import json
import markdown2
import os
import re
import sys
from html import unescape
from rich.console import Console

STATE_FILE = "slide_state.json"


def get_sections(text):
    """
    Splits the markdown text into sections. A section is any block that begins
    with a heading (a line starting with '#' up to '######') that is not inside a code fence.
    """
    sections = []
    current = []
    in_code_block = False
    # Recognize both ``` and ~~~ as code fences.
    code_fence_pattern = re.compile(r"^\s*(```|~~~)")
    heading_pattern = re.compile(r"^(#{1,6})\s+")

    for line in text.splitlines():
        if code_fence_pattern.match(line):
            in_code_block = not in_code_block
        # Only consider a heading if not inside a code block.
        if not in_code_block and heading_pattern.match(line):
            if current:
                sections.append("\n".join(current))
            current = [line]
        else:
            current.append(line)
    if current:
        sections.append("\n".join(current))
    return sections


def load_state():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return None


def save_state(state):
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f)


def html_to_rich(html):
    """
    Converts a subset of HTML (as generated by markdown2) to Rich markup.
    This covers headings, bold, italics, inline and fenced code blocks, and links.
    """
    # Convert fenced code blocks first (<pre><code>...</code></pre>)
    html = re.sub(
        r"<pre><code>(.*?)</code></pre>",
        lambda m: f"[reverse yellow]{m.group(1).strip()}[/reverse yellow]",
        html,
        flags=re.DOTALL,
    )
    # Headings with left alignment (just by not adding any alignment tag)
    html = re.sub(
        r"<h1>(.*?)</h1>",
        lambda m: f"[bold underline red]{m.group(1).strip()}[/bold underline red]",
        html,
        flags=re.DOTALL,
    )
    html = re.sub(
        r"<h2>(.*?)</h2>",
        lambda m: f"[bold underline green]{m.group(1).strip()}[/bold underline green]",
        html,
        flags=re.DOTALL,
    )
    html = re.sub(
        r"<h3>(.*?)</h3>",
        lambda m: f"[bold underline blue]{m.group(1).strip()}[/bold underline blue]",
        html,
        flags=re.DOTALL,
    )
    # h4-h6: simply bolded.
    html = re.sub(
        r"<h[4-6]>(.*?)</h[4-6]>",
        lambda m: f"[bold]{m.group(1).strip()}[/bold]\n",
        html,
        flags=re.DOTALL,
    )
    # Bold and italics.
    html = re.sub(
        r"<strong>(.*?)</strong>",
        lambda m: f"[bold red]{m.group(1).strip()}[/bold red]",
        html,
        flags=re.DOTALL,
    )
    html = re.sub(
        r"<em>(.*?)</em>",
        lambda m: f"[italic dim]{m.group(1).strip()}[/italic dim]",
        html,
        flags=re.DOTALL,
    )
    # Inline code.
    html = re.sub(
        r"<code>(.*?)</code>",
        lambda m: f"[reverse yellow]{m.group(1).strip()}[/reverse yellow]",
        html,
        flags=re.DOTALL,
    )
    # Links (ignore URL, color the link text)
    html = re.sub(
        r'<a href="[^"]*">(.*?)</a>',
        lambda m: f"[underline cyan]{m.group(1).strip()}[/underline cyan]",
        html,
        flags=re.DOTALL,
    )
    # Remove paragraph tags.
    html = re.sub(r"</?p>", "", html, flags=re.DOTALL)
    # Remove any remaining stray HTML tags.
    html = re.sub(r"<[^>]+>", "", html)
    # Unescape HTML entities
    html = unescape(html.replace("&nsbp;", " "))
    # Replace 3+ newlines with a 2 newlines
    return re.sub(r"\n\n\n+", "\n\n", html).strip()


def clear_screen():
    os.system("cls" if os.name == "nt" else "clear")


def main():
    # Parse command-line arguments.
    args = sys.argv[1:]
    filename = None
    prev_flag, current_flag = False, False
    for arg in args:
        if arg in ("-p", "--prev"):
            prev_flag = True
        elif arg in ("-c", "--current"):
            current_flag = True
        elif not arg.startswith("-"):
            filename = arg

    # If a filename is provided, reset state.
    if filename:
        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            sys.exit(1)
        with open(filename, "r", encoding="utf-8") as f:
            content = f.read()
        sections = get_sections(content)
        if not sections:
            print("No sections found in the file.")
            sys.exit(0)
        # Reset state with the first slide.
        state = {"filename": filename, "current_slide": 0, "total": len(sections)}
        slide_index = 0
        save_state(state)
    else:
        state = load_state()
        if not state:
            print("No state found. Please run with a markdown file first.")
            sys.exit(1)
        filename = state["filename"]
        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            sys.exit(1)
        with open(filename, "r", encoding="utf-8") as f:
            content = f.read()
        sections = get_sections(content)
        total = len(sections)
        current = state["current_slide"]

        if prev_flag:
            if current == 0:
                print("Already at the first slide. Cannot go back further.")
                sys.exit(0)
            slide_index = current - 1
        elif current_flag:
            slide_index = current
        else:
            slide_index = current + 1
            if slide_index >= total:
                print("No more sections to render. Exiting.")
                os.remove(STATE_FILE)
                sys.exit(0)
        state["current_slide"] = slide_index
        state["total"] = total
        save_state(state)

    # Clear screen before printing the slide.
    clear_screen()

    # Convert markdown to HTML (with fenced-code-blocks extra) then to Rich markup.
    html = markdown2.markdown(sections[slide_index], extras=["fenced-code-blocks"])
    rich_markup = html_to_rich(html)

    console = Console()
    console.print(rich_markup + "\n", markup=True, justify="left")


if __name__ == "__main__":
    main()
